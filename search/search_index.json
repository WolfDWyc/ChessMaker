{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"ChessMaker","text":"<p>An easily extendible chess implementation designed to support any custom rule or feature.</p> <p> Play: https://chessmaker.fly.dev </p> <p>Documentation: https://wolfdwyc.github.io/ChessMaker</p> <p>Source Code: https://github.com/WolfDWyc/ChessMaker</p>"},{"location":"#what-is-chessmaker","title":"What is ChessMaker?","text":"<p>ChessMaker is a Python (3.11+) chess implementation that can be extended to support any custom rule or feature. It allows you to build almost any variant you can think of easily and quickly.</p> <p>It was inspired by r/AnarchyChess - and the packaged optional rules are almost all inspired by that subreddit.</p> <p>ChessMaker isn't tied to any GUI, but comes with a thin, pywebio, multiplayer web interface. The web interface supports choosing from the packaged rules, singleplayer (vs Yourself), and multiplayer (vs a friend or random opponent). It also supports saving and loading games - which can be shared with others and be used as puzzles.</p> <p>The packaged rules are:</p> <ul> <li>Chess960</li> <li>Knooks</li> <li>Forced En Passant</li> <li>Knight Boosting</li> <li>Siberian Swipe</li> <li>Il Vaticano</li> <li>Beta Decay</li> <li>La Bastarda</li> <li>Omnipotent F6 Pawn</li> <li>King Cant Move to C2</li> <li>Vertical Castling</li> <li>Double Check to Win</li> <li>Capture All Pieces to Win</li> <li>Duck Chess</li> </ul> <p>Contributions of new variants or anything else you'd like to see in the project are welcome!</p>"},{"location":"#what-chessmaker-isnt","title":"What ChessMaker isn't","text":"<ul> <li>A complete chess server - It currently doesn't support users, matchmaking, ratings, cheating detection, and is very thin. The frontend is very simple and currently not the focus of the project.</li> <li>A chess engine - The design choices are not optimized for speed, and it doesn't provide any analysis or AI.</li> <li>A compliant or standard chess implementation - It doesn't support UCI or existing chess GUIs, because it allows rules that wouldn't be possible with those.</li> </ul> <p>Note</p> <p>While ChessMaker isn't a chess server, one could be built on top of it, and development of alternative clients to it is welcomed and encouraged. If this project gets enough interest, a more complete server might be added.</p>"},{"location":"getting-started/","title":"Getting started - Creating a custom game","text":""},{"location":"getting-started/#installation","title":"Installation","text":"<pre><code>$ pip install chessmaker\n</code></pre>"},{"location":"getting-started/#usage","title":"Usage","text":""},{"location":"getting-started/#using-the-provided-game-factory","title":"Using the provided game factory","text":"<p>This is what runs on the online example:</p> <pre><code>from chessmaker.chess import create_game\nfrom chessmaker.clients import start_pywebio_chess_server, PIECE_URLS\n\nif __name__ == \"__main__\":\n    start_pywebio_chess_server(\n        create_game, # (1)\n        supported_options=[\"chess960\", \"knooks\", \"forced_en_passant\", \"knight_boosting\", \"omnipotent_f6_pawn\",\n                           \"siberian_swipe\", \"il_vaticano\", \"beta_decay\", \"la_bastarda\", \"king_cant_move_to_c2\",\n                           \"vertical_castling\", \"double_check_to_win\", \"capture_all_pieces_to_win\", \"duck_chess\"],\n        piece_urls=PIECE_URLS |\n                   {\n                       \"Knook\": [\"https://i.imgur.com/UiWcdEb.png\", \"https://i.imgur.com/g7xTVts.png\"],\n                       \"Duck\": [\"https://i.imgur.com/ZZ2WSUq.png\", \"https://i.imgur.com/ZZ2WSUq.png\"]\n                   } # (2)\n        ,remote_access=True # (3)\n    )\n</code></pre> <ol> <li> <p>The game_factory argument is a function that creates a new game instance. The factory function should accept a list of boolean keyword arguments, which are specified in the supported_options argument. Accepting options are useful if you want to host a server that supports multiple variants of chess, but most of the time you know what variant you want to play, so it's not needed.</p> </li> <li> <p>In order to use custom pieces, you need to provide the URLs of the images as a tuple with a URL for each player.</p> </li> <li> <p>The remote_access argument puts the server on the internet, so you can play with your friends! It uses pywebio's remote access feature (which internally uses http://localhost.run).</p> </li> </ol>"},{"location":"getting-started/#creating-a-standard-game-factory","title":"Creating a standard game factory","text":"<p>Now, let's make our own game factory. This one won't support any custom rules - just the standard chess rules.</p> <pre><code>from itertools import cycle\n\nfrom chessmaker.chess.base import Board\nfrom chessmaker.chess.base import Game\nfrom chessmaker.chess.base import Player\nfrom chessmaker.chess.base import Square\nfrom chessmaker.chess.pieces import Bishop\nfrom chessmaker.chess.pieces import King\nfrom chessmaker.chess.pieces import Knight\nfrom chessmaker.chess.pieces import Pawn\nfrom chessmaker.chess.pieces import Queen\nfrom chessmaker.chess.pieces import Rook\nfrom chessmaker.chess.results import no_kings, checkmate, stalemate, Repetition, NoCapturesOrPawnMoves\nfrom chessmaker.clients import start_pywebio_chess_server\n\n\ndef _empty_line(length: int) -&gt; list[Square]:\n    return [Square() for _ in range(length)]\n\ndef get_result(board: Board) -&gt; str:\n    for result_function in [no_kings, checkmate, stalemate, Repetition(3), NoCapturesOrPawnMoves(50)]:\n        result = result_function(board)\n        if result:\n            return result\n\npiece_row = [Rook, Knight, Bishop, Queen, King, Bishop, Knight, Rook]\n\ndef create_game(**_) -&gt; Game:\n    white = Player(\"white\")\n    black = Player(\"black\")\n    turn_iterator = cycle([white, black])\n\n    def _pawn(player: Player):\n        if player == white:\n            return Pawn(white, Pawn.Direction.UP, promotions=[Bishop, Rook, Queen, Knight])\n        elif player == black:\n            return Pawn(black, Pawn.Direction.DOWN, promotions=[Bishop, Rook, Queen, Knight])\n\n    game = Game(\n        board=Board(\n            squares=[\n                [Square(piece_row[i](black)) for i in range(8)],\n                [Square(_pawn(black)) for _ in range(8)],\n                _empty_line(8),\n                _empty_line(8),\n                _empty_line(8),\n                _empty_line(8),\n                [Square(_pawn(white)) for _ in range(8)],\n                [Square(piece_row[i](white)) for i in range(8)],\n            ],\n            players=[white, black],\n            turn_iterator=turn_iterator,\n        ),\n        get_result=get_result,\n    )\n\n    return game\n\n\nif __name__ == \"__main__\":\n    start_pywebio_chess_server(create_game, debug=True)\n</code></pre> <p>We aren't going to get into the details of how things work behind the scenes yet, but let's break down what's going on here.</p> <p>Our game object is created with 2 arguments. Let's start with the simpler one.</p> <p>The get_result argument is the function that will be called to determine the result of the game. We create a result function that checks for all the standard end conditions: checkmate, stalemate, repetition, and the 50 move rule. For simplicity, we could have also imported <code>StandardResult</code> for the same effect.</p> <p>The board argument is the main object we'll be working with, and it is created with 3 arguments. Again, let's do the simpler arguments first.</p> <p>The players argument is a list of the players in the game. In most cases, we'll have 2 players - but it's possible to have more. The names of the players are currently only used for display purposes.</p> <p>Because ChessMaker supports altering the player's turns, we can't just use the player list to determine who's turn it is. The turn_iterator argument is a generator that will be called to get the next player in the turn order.</p> <p>The square argument is a 2D list of <code>Square</code> objects. Squares can also be <code>None</code>, if we want to make non-rectangular boards or have a board with holes in it.</p> <p>Each square accepts an optional piece argument, which is the piece that will be placed on the square. A piece always needs to accept a player argument.</p> <p>The first and last ranks are pretty simple. We just create a list of the pieces we want to use, and create a square for each one. This is because none of the pieces on those ranks need any extra arguments.</p> <p>For our pawns, we need to specify the direction they can move in - and what can they promote to. We can do this using the direction and promotions arguments.</p> <p>The result is a complete chess game, with all the standard rules:</p> <p></p>"},{"location":"getting-started/#creating-a-custom-game-factory","title":"Creating a custom game factory","text":"<p>Now that we've seen how to create a basic game factory, let's look at how to create a custom one. In this example, we'll create a 5x5 board, pawns on the corners, kings in the middle of the edge ranks, bishops between the pawns and the kings - and a hole in the middle of the board.</p> <pre><code>from itertools import cycle\n\nfrom chessmaker.chess.base import Board\nfrom chessmaker.chess.base import Game\nfrom chessmaker.chess.base import Player\nfrom chessmaker.chess.base import Square\nfrom chessmaker.chess.pieces import Bishop\nfrom chessmaker.chess.pieces import King\nfrom chessmaker.chess.pieces import Pawn\nfrom chessmaker.chess.results import StandardResult\nfrom chessmaker.clients import start_pywebio_chess_server\n\ndef _empty_line(length: int) -&gt; list[Square]:\n    return [Square() for _ in range(length)]\n\n\ndef create_custom_game(*_):\n    white = Player(\"white\")\n    black = Player(\"black\")\n    turn_iterator = cycle([white, black])\n\n    def _pawn(player: Player):\n        if player == white:\n            return Pawn(white, Pawn.Direction.UP, promotions=[Bishop])\n        elif player == black:\n            return Pawn(black, Pawn.Direction.DOWN, promotions=[Bishop])\n\n    game = Game(\n        board=Board(\n            squares=[\n                [Square(piece(black)) for piece in [_pawn, Bishop, King, Bishop, _down_pawn]],\n                _empty_line(5),\n                _empty_line(2) + [None] + _empty_line(2),\n                _empty_line(5),\n                [Square(piece(white)) for piece in [_pawn, Bishop, King, Bishop, _up_pawn]],\n            ],\n            players=[white, black],\n            turn_iterator=turn_iterator,\n        ),\n        get_result=StandardResult(),\n    )\n\n    return game\n\n\nif __name__ == \"__main__\":\n    start_pywebio_chess_server(create_custom_game, debug=True)\n</code></pre> <p>And the result:</p> <p></p>"},{"location":"packaged-variants/","title":"Packaged Variants","text":"<p>This is a list of variants that are packaged in the main repository and are available in the online version of the game.</p> <p>You can enable any combination of these variants in the game by checking the appropriate boxes in the \"Options\" section of the \"New Game\" screen.</p> Variant Description Chess960 Chess960, as described here. Knooks Rooks and knights of the same player can be moved to the same position and merge into a Knook: a piece that moves both like a rook and a knight (but cannot castle). Forced En Passant En passant capture is mandatory if available. If a player is checked and can en passant, they lose. A player can move into a position that will put their king under attack if the next player must en passant instead of taking the king. Knight Boosting When a pawn is promoted to a knight, the player gets an extra turn to move that knight. Omnipotent F6 Pawn When there is an enemy piece on F6, a pawn can be summoned there. Siberian Swipe When a Rook hasn't moved yet, it can jump over all pieces in a file to capture an enemy opponent's rook. Il Vaticano When 2 bishops of the same player have a 2-square gap between them, and that gap is filled by 2 enemy pieces, the bishops can switch places, capturing both enemy pieces. Beta Decay When a queen has an empty, straight, line of 3 or more squares with a board edge, hole, or a piece of the same player - it can split to a rook, bishop, and pawn - in that order. La Bastarda When a queen is moved to an enemy king, the king can move away directly opposite from the queen, summoning a pawn of the same player as the queen between them. King Cant Move to C2 Kings cannot move to C2. Vertical Castling Castlling can also be done vertically. Double Check To Win In addition to checkmating, a player can win by giving check with 2 pieces or more. Capture All Pieces To Win Instead of checkmating, a player can win by capturing all pieces of the opponent. Kings can be under attack and can be taken. Duck Chess There is a Duck on the board which can not capture or be captured, but can move to any position. After playing a turn, the player has to move duck to a different square. There are no checks, and you lose by getting your King captured."},{"location":"api-reference/board/","title":"Board","text":""},{"location":"api-reference/board/#chessmakerchessbaseboard","title":"chessmaker.chess.base.board","text":"<p>[view_source]</p> <p></p>"},{"location":"api-reference/board/#afternewpieceevent","title":"AfterNewPieceEvent","text":"<pre><code>@dataclass(frozen=True)\nclass AfterNewPieceEvent(Event)\n</code></pre> <p>[view_source]</p> <p></p>"},{"location":"api-reference/board/#piece-piece","title":"piece: <code>Piece</code>","text":"<p>[view_source]</p> <p></p>"},{"location":"api-reference/board/#afterremovesquareevent","title":"AfterRemoveSquareEvent","text":"<pre><code>@dataclass(frozen=True)\nclass AfterRemoveSquareEvent(Event)\n</code></pre> <p>[view_source]</p> <p></p>"},{"location":"api-reference/board/#position-position","title":"position: <code>Position</code>","text":"<p>[view_source]</p> <p></p>"},{"location":"api-reference/board/#square-square","title":"square: <code>Square</code>","text":"<p>[view_source]</p> <p></p>"},{"location":"api-reference/board/#beforeremovesquareevent","title":"BeforeRemoveSquareEvent","text":"<pre><code>@dataclass(frozen=True)\nclass BeforeRemoveSquareEvent(AfterRemoveSquareEvent)\n</code></pre> <p>[view_source]</p> <p></p>"},{"location":"api-reference/board/#afteraddsquareevent","title":"AfterAddSquareEvent","text":"<pre><code>@dataclass(frozen=True)\nclass AfterAddSquareEvent(Event)\n</code></pre> <p>[view_source]</p> <p></p>"},{"location":"api-reference/board/#position-position_1","title":"position: <code>Position</code>","text":"<p>[view_source]</p> <p></p>"},{"location":"api-reference/board/#square-square_1","title":"square: <code>Square</code>","text":"<p>[view_source]</p> <p></p>"},{"location":"api-reference/board/#beforeaddsquareevent","title":"BeforeAddSquareEvent","text":"<pre><code>@dataclass(frozen=True)\nclass BeforeAddSquareEvent(AfterAddSquareEvent)\n</code></pre> <p>[view_source]</p> <p></p>"},{"location":"api-reference/board/#set_square","title":"set_square","text":"<pre><code>def set_square(square: Square)\n</code></pre> <p>[view_source]</p> <p></p>"},{"location":"api-reference/board/#beforeturnchangeevent","title":"BeforeTurnChangeEvent","text":"<pre><code>@dataclass(frozen=True)\nclass BeforeTurnChangeEvent(CancellableEvent)\n</code></pre> <p>[view_source]</p> <p></p>"},{"location":"api-reference/board/#board-board","title":"board: <code>\"Board\"</code>","text":"<p>[view_source]</p> <p></p>"},{"location":"api-reference/board/#next_player-player","title":"next_player: <code>Player</code>","text":"<p>[view_source]</p> <p></p>"},{"location":"api-reference/board/#set_next_player","title":"set_next_player","text":"<pre><code>def set_next_player(next_player: Player)\n</code></pre> <p>[view_source]</p> <p></p>"},{"location":"api-reference/board/#afterturnchangeevent","title":"AfterTurnChangeEvent","text":"<pre><code>@dataclass(frozen=True)\nclass AfterTurnChangeEvent(Event)\n</code></pre> <p>[view_source]</p> <p></p>"},{"location":"api-reference/board/#board-board_1","title":"board: <code>\"Board\"</code>","text":"<p>[view_source]</p> <p></p>"},{"location":"api-reference/board/#player-player","title":"player: <code>Player</code>","text":"<p>[view_source]</p> <p></p>"},{"location":"api-reference/board/#board","title":"Board","text":"<pre><code>@event_publisher(*SQUARE_EVENT_TYPES, *PIECE_EVENT_TYPES, BeforeAddSquareEvent, AfterAddSquareEvent,\n                 BeforeRemoveSquareEvent, AfterRemoveSquareEvent, BeforeTurnChangeEvent, AfterTurnChangeEvent,\n                 AfterNewPieceEvent)\nclass Board(Cloneable,  EventPublisher)\n</code></pre> <p>[view_source]</p> <p></p>"},{"location":"api-reference/board/#__init__","title":"__init__","text":"<pre><code>def __init__(squares: list[list[Square | None]], players: list[Player], turn_iterator: Iterator[Player], rules: list[Rule] = None)\n</code></pre> <p>[view_source]</p> <p></p>"},{"location":"api-reference/board/#__getitem__","title":"__getitem__","text":"<pre><code>def __getitem__(position: Position) -&gt; Square | None\n</code></pre> <p>[view_source]</p> <p></p>"},{"location":"api-reference/board/#__setitem__","title":"__setitem__","text":"<pre><code>def __setitem__(position: Position, square: Square | None)\n</code></pre> <p>[view_source]</p> <p></p>"},{"location":"api-reference/board/#__iter__","title":"__iter__","text":"<pre><code>def __iter__() -&gt; Iterable[Square]\n</code></pre> <p>[view_source]</p> <p></p>"},{"location":"api-reference/board/#get_pieces","title":"get_pieces","text":"<pre><code>def get_pieces() -&gt; Iterable[Piece]\n</code></pre> <p>[view_source]</p> <p></p>"},{"location":"api-reference/board/#get_player_pieces","title":"get_player_pieces","text":"<pre><code>def get_player_pieces(player: Player) -&gt; Iterable[Piece]\n</code></pre> <p>[view_source]</p> <p></p>"},{"location":"api-reference/board/#clone","title":"clone","text":"<pre><code>def clone()\n</code></pre> <p>[view_source]</p>"},{"location":"api-reference/events/","title":"Events","text":""},{"location":"api-reference/events/#chessmakereventsevent","title":"chessmaker.events.event","text":"<p>[view_source]</p> <p></p>"},{"location":"api-reference/events/#event","title":"Event","text":"<pre><code>@dataclass(frozen=True)\nclass Event()\n</code></pre> <p>[view_source]</p> <p></p>"},{"location":"api-reference/events/#cancellableevent","title":"CancellableEvent","text":"<pre><code>@dataclass(frozen=True)\nclass CancellableEvent(Event)\n</code></pre> <p>[view_source]</p> <p></p>"},{"location":"api-reference/events/#cancelled-bool","title":"cancelled: <code>bool</code>","text":"<p>[view_source]</p> <p></p>"},{"location":"api-reference/events/#set_cancelled","title":"set_cancelled","text":"<pre><code>def set_cancelled(cancelled: bool)\n</code></pre> <p>[view_source]</p> <p></p>"},{"location":"api-reference/events/#chessmakereventsevent_priority","title":"chessmaker.events.event_priority","text":"<p>[view_source]</p> <p></p>"},{"location":"api-reference/events/#eventpriority","title":"EventPriority","text":"<pre><code>class EventPriority(int,  Enum)\n</code></pre> <p>[view_source]</p> <p></p>"},{"location":"api-reference/events/#very_low","title":"VERY_LOW","text":"<p>[view_source]</p> <p></p>"},{"location":"api-reference/events/#low","title":"LOW","text":"<p>[view_source]</p> <p></p>"},{"location":"api-reference/events/#normal","title":"NORMAL","text":"<p>[view_source]</p> <p></p>"},{"location":"api-reference/events/#high","title":"HIGH","text":"<p>[view_source]</p> <p></p>"},{"location":"api-reference/events/#very_high","title":"VERY_HIGH","text":"<p>[view_source]</p> <p></p>"},{"location":"api-reference/events/#chessmakereventsevent_publisher","title":"chessmaker.events.event_publisher","text":"<p>[view_source]</p> <p></p>"},{"location":"api-reference/events/#eventpublisher","title":"EventPublisher","text":"<pre><code>class EventPublisher()\n</code></pre> <p>[view_source]</p> <p></p>"},{"location":"api-reference/events/#__init__","title":"__init__","text":"<pre><code>def __init__(event_types: tuple[Type[Event], ...] = None)\n</code></pre> <p>[view_source]</p> <p></p>"},{"location":"api-reference/events/#subscribe","title":"subscribe","text":"<pre><code>def subscribe(event_type: Type[TEvent], callback: Callable[[TEvent], None], priority: int = EventPriority.NORMAL)\n</code></pre> <p>[view_source]</p> <p></p>"},{"location":"api-reference/events/#unsubscribe","title":"unsubscribe","text":"<pre><code>def unsubscribe(event_type: Type[TEvent], callback: Callable[[TEvent], None])\n</code></pre> <p>[view_source]</p> <p></p>"},{"location":"api-reference/events/#subscribe_to_all","title":"subscribe_to_all","text":"<pre><code>def subscribe_to_all(callback: Callable[[Event], None], priority: int = EventPriority.NORMAL)\n</code></pre> <p>[view_source]</p> <p></p>"},{"location":"api-reference/events/#unsubscribe_from_all","title":"unsubscribe_from_all","text":"<pre><code>def unsubscribe_from_all(callback: Callable[[Event], None])\n</code></pre> <p>[view_source]</p> <p></p>"},{"location":"api-reference/events/#publish","title":"publish","text":"<pre><code>def publish(event: Event)\n</code></pre> <p>[view_source]</p> <p></p>"},{"location":"api-reference/events/#propagate","title":"propagate","text":"<pre><code>def propagate(publisher: 'EventPublisher', event_type: Type[Event])\n</code></pre> <p>[view_source]</p> <p>For all events publisher publishes of type event_type, publish them to self</p> <p></p>"},{"location":"api-reference/events/#propagate_all","title":"propagate_all","text":"<pre><code>def propagate_all(publisher: 'EventPublisher')\n</code></pre> <p>[view_source]</p> <p>For all events publisher publishes, publish them to self</p> <p></p>"},{"location":"api-reference/events/#event_publisher","title":"event_publisher","text":"<pre><code>def event_publisher(*event_types: Type[Event]) -&gt; Callable[[Type[T]], Type[T] | Type[EventPublisher]]\n</code></pre> <p>[view_source]</p>"},{"location":"api-reference/game/","title":"Game","text":""},{"location":"api-reference/game/#chessmakerchessbasegame","title":"chessmaker.chess.base.game","text":"<p>[view_source]</p> <p></p>"},{"location":"api-reference/game/#aftergameendevent","title":"AfterGameEndEvent","text":"<pre><code>@dataclass(frozen=True)\nclass AfterGameEndEvent(Event)\n</code></pre> <p>[view_source]</p> <p></p>"},{"location":"api-reference/game/#game-game","title":"game: <code>\"Game\"</code>","text":"<p>[view_source]</p> <p></p>"},{"location":"api-reference/game/#result-str","title":"result: <code>str</code>","text":"<p>[view_source]</p> <p></p>"},{"location":"api-reference/game/#game","title":"Game","text":"<pre><code>@event_publisher(AfterGameEndEvent)\nclass Game(EventPublisher)\n</code></pre> <p>[view_source]</p> <p></p>"},{"location":"api-reference/game/#__init__","title":"__init__","text":"<pre><code>def __init__(board: Board, get_result: Callable[[Board], str | None])\n</code></pre> <p>[view_source]</p>"},{"location":"api-reference/move-option/","title":"MoveOption","text":""},{"location":"api-reference/move-option/#chessmakerchessbasemove_option","title":"chessmaker.chess.base.move_option","text":"<p>[view_source]</p> <p></p>"},{"location":"api-reference/move-option/#moveoption","title":"MoveOption","text":"<pre><code>@dataclass\nclass MoveOption()\n</code></pre> <p>[view_source]</p> <p></p>"},{"location":"api-reference/move-option/#position-position","title":"position: <code>Position</code>","text":"<p>[view_source]</p> <p></p>"},{"location":"api-reference/move-option/#captures-setposition","title":"captures: <code>set[Position]</code>","text":"<p>[view_source]</p> <p></p>"},{"location":"api-reference/move-option/#extra-dictstr-any","title":"extra: <code>dict[str, any]</code>","text":"<p>[view_source]</p>"},{"location":"api-reference/piece-utils/","title":"Piece Utilities","text":""},{"location":"api-reference/piece-utils/#chessmakerchesspiece_utils","title":"chessmaker.chess.piece_utils","text":"<p>[view_source]</p> <p></p>"},{"location":"api-reference/piece-utils/#is_in_board","title":"is_in_board","text":"<pre><code>def is_in_board(board: Board, position: Position) -&gt; bool\n</code></pre> <p>[view_source]</p> <p></p>"},{"location":"api-reference/piece-utils/#iterate_until_blocked","title":"iterate_until_blocked","text":"<pre><code>def iterate_until_blocked(piece: Piece, direction: tuple[int, int]) -&gt; Iterable[Position]\n</code></pre> <p>[view_source]</p> <p></p>"},{"location":"api-reference/piece-utils/#get_diagonals_until_blocked","title":"get_diagonals_until_blocked","text":"<pre><code>def get_diagonals_until_blocked(piece: Piece) -&gt; Iterable[Position]\n</code></pre> <p>[view_source]</p> <p></p>"},{"location":"api-reference/piece-utils/#get_horizontal_until_blocked","title":"get_horizontal_until_blocked","text":"<pre><code>def get_horizontal_until_blocked(piece: Piece) -&gt; Iterable[Position]\n</code></pre> <p>[view_source]</p> <p></p>"},{"location":"api-reference/piece-utils/#get_vertical_until_blocked","title":"get_vertical_until_blocked","text":"<pre><code>def get_vertical_until_blocked(piece: Piece) -&gt; Iterable[Position]\n</code></pre> <p>[view_source]</p> <p></p>"},{"location":"api-reference/piece-utils/#get_straight_until_blocked","title":"get_straight_until_blocked","text":"<pre><code>def get_straight_until_blocked(piece: Piece) -&gt; Iterable[Position]\n</code></pre> <p>[view_source]</p> <p></p>"},{"location":"api-reference/piece-utils/#filter_uncapturable_positions","title":"filter_uncapturable_positions","text":"<pre><code>def filter_uncapturable_positions(piece: Piece, positions: Iterable[Position]) -&gt; Iterable[Position]\n</code></pre> <p>[view_source]</p> <p></p>"},{"location":"api-reference/piece-utils/#positions_to_move_options","title":"positions_to_move_options","text":"<pre><code>def positions_to_move_options(board: Board, positions: Iterable[Position]) -&gt; Iterable[MoveOption]\n</code></pre> <p>[view_source]</p>"},{"location":"api-reference/piece/","title":"Piece","text":""},{"location":"api-reference/piece/#chessmakerchessbasepiece","title":"chessmaker.chess.base.piece","text":"<p>[view_source]</p> <p></p>"},{"location":"api-reference/piece/#aftergetmoveoptionsevent","title":"AfterGetMoveOptionsEvent","text":"<pre><code>@dataclass(frozen=True)\nclass AfterGetMoveOptionsEvent(Event)\n</code></pre> <p>[view_source]</p> <p></p>"},{"location":"api-reference/piece/#piece-piece","title":"piece: <code>\"Piece\"</code>","text":"<p>[view_source]</p> <p></p>"},{"location":"api-reference/piece/#move_options-iterablemoveoption","title":"move_options: <code>Iterable[MoveOption]</code>","text":"<p>[view_source]</p> <p></p>"},{"location":"api-reference/piece/#beforegetmoveoptionsevent","title":"BeforeGetMoveOptionsEvent","text":"<pre><code>class BeforeGetMoveOptionsEvent(AfterGetMoveOptionsEvent)\n</code></pre> <p>[view_source]</p> <p></p>"},{"location":"api-reference/piece/#set_move_options","title":"set_move_options","text":"<pre><code>def set_move_options(move_options: Iterable[MoveOption])\n</code></pre> <p>[view_source]</p> <p></p>"},{"location":"api-reference/piece/#aftermoveevent","title":"AfterMoveEvent","text":"<pre><code>@dataclass(frozen=True)\nclass AfterMoveEvent(Event)\n</code></pre> <p>[view_source]</p> <p></p>"},{"location":"api-reference/piece/#piece-piece_1","title":"piece: <code>\"Piece\"</code>","text":"<p>[view_source]</p> <p></p>"},{"location":"api-reference/piece/#move_option-moveoption","title":"move_option: <code>MoveOption</code>","text":"<p>[view_source]</p> <p></p>"},{"location":"api-reference/piece/#beforemoveevent","title":"BeforeMoveEvent","text":"<pre><code>class BeforeMoveEvent(AfterMoveEvent,  CancellableEvent)\n</code></pre> <p>[view_source]</p> <p></p>"},{"location":"api-reference/piece/#set_move_option","title":"set_move_option","text":"<pre><code>def set_move_option(move_option: MoveOption)\n</code></pre> <p>[view_source]</p> <p></p>"},{"location":"api-reference/piece/#aftercapturedevent","title":"AfterCapturedEvent","text":"<pre><code>@dataclass(frozen=True)\nclass AfterCapturedEvent(Event)\n</code></pre> <p>[view_source]</p> <p></p>"},{"location":"api-reference/piece/#captured_piece-piece","title":"captured_piece: <code>\"Piece\"</code>","text":"<p>[view_source]</p> <p></p>"},{"location":"api-reference/piece/#beforecapturedevent","title":"BeforeCapturedEvent","text":"<pre><code>class BeforeCapturedEvent(AfterCapturedEvent)\n</code></pre> <p>[view_source]</p> <p></p>"},{"location":"api-reference/piece/#piece_event_types","title":"PIECE_EVENT_TYPES","text":"<p>[view_source]</p> <p></p>"},{"location":"api-reference/piece/#piece","title":"Piece","text":"<pre><code>@event_publisher(*PIECE_EVENT_TYPES)\nclass Piece(Cloneable,  EventPublisher)\n</code></pre> <p>[view_source]</p> <p></p>"},{"location":"api-reference/piece/#__init__","title":"__init__","text":"<pre><code>def __init__(player: Player)\n</code></pre> <p>[view_source]</p> <p></p>"},{"location":"api-reference/piece/#__repr__","title":"__repr__","text":"<pre><code>def __repr__()\n</code></pre> <p>[view_source]</p> <p></p>"},{"location":"api-reference/piece/#get_move_options","title":"get_move_options","text":"<pre><code>def get_move_options() -&gt; Iterable[MoveOption]\n</code></pre> <p>[view_source]</p> <p></p>"},{"location":"api-reference/piece/#move","title":"move","text":"<pre><code>def move(move_option: MoveOption)\n</code></pre> <p>[view_source]</p> <p></p>"},{"location":"api-reference/piece/#on_join_board","title":"on_join_board","text":"<pre><code>def on_join_board()\n</code></pre> <p>[view_source]</p> <p></p>"},{"location":"api-reference/piece/#position","title":"position","text":"<pre><code>@property\ndef position()\n</code></pre> <p>[view_source]</p> <p></p>"},{"location":"api-reference/piece/#board","title":"board","text":"<pre><code>@property\ndef board()\n</code></pre> <p>[view_source]</p> <p></p>"},{"location":"api-reference/piece/#name","title":"name","text":"<pre><code>@classmethod\n@property\n@abstractmethod\ndef name(cls)\n</code></pre> <p>[view_source]</p> <p></p>"},{"location":"api-reference/piece/#clone","title":"clone","text":"<pre><code>@abstractmethod\ndef clone()\n</code></pre> <p>[view_source]</p>"},{"location":"api-reference/player/","title":"Player","text":""},{"location":"api-reference/player/#chessmakerchessbaseplayer","title":"chessmaker.chess.base.player","text":"<p>[view_source]</p> <p></p>"},{"location":"api-reference/player/#player","title":"Player","text":"<pre><code>@dataclass(frozen=True)\nclass Player()\n</code></pre> <p>[view_source]</p> <p></p>"},{"location":"api-reference/player/#name-str","title":"name: <code>str</code>","text":"<p>[view_source]</p> <p></p>"},{"location":"api-reference/player/#__repr__","title":"__repr__","text":"<pre><code>def __repr__()\n</code></pre> <p>[view_source]</p>"},{"location":"api-reference/position/","title":"Position","text":""},{"location":"api-reference/position/#chessmakerchessbaseposition","title":"chessmaker.chess.base.position","text":"<p>[view_source]</p> <p></p>"},{"location":"api-reference/position/#position","title":"Position","text":"<pre><code>class Position(NamedTuple)\n</code></pre> <p>[view_source]</p> <p></p>"},{"location":"api-reference/position/#x-int","title":"x: <code>int</code>","text":"<p>[view_source]</p> <p></p>"},{"location":"api-reference/position/#y-int","title":"y: <code>int</code>","text":"<p>[view_source]</p> <p></p>"},{"location":"api-reference/position/#__str__","title":"__str__","text":"<pre><code>def __str__()\n</code></pre> <p>[view_source]</p> <p></p>"},{"location":"api-reference/position/#offset","title":"offset","text":"<pre><code>def offset(x: int, y: int)\n</code></pre> <p>[view_source]</p>"},{"location":"api-reference/rule/","title":"Rule","text":""},{"location":"api-reference/rule/#chessmakerchessbaserule","title":"chessmaker.chess.base.rule","text":"<p>[view_source]</p> <p></p>"},{"location":"api-reference/rule/#rule","title":"Rule","text":"<pre><code>class Rule(Cloneable)\n</code></pre> <p>[view_source]</p> <p></p>"},{"location":"api-reference/rule/#on_join_board","title":"on_join_board","text":"<pre><code>@abstractmethod\ndef on_join_board(board: \"Board\")\n</code></pre> <p>[view_source]</p> <p></p>"},{"location":"api-reference/rule/#clone","title":"clone","text":"<pre><code>@abstractmethod\ndef clone()\n</code></pre> <p>[view_source]</p> <p></p>"},{"location":"api-reference/rule/#as_rule","title":"as_rule","text":"<pre><code>def as_rule(rule_func: Callable[[\"Board\"], None]) -&gt; Type[Rule]\n</code></pre> <p>[view_source]</p>"},{"location":"api-reference/square/","title":"Square","text":""},{"location":"api-reference/square/#chessmakerchessbasesquare","title":"chessmaker.chess.base.square","text":"<p>[view_source]</p> <p></p>"},{"location":"api-reference/square/#afteraddpieceevent","title":"AfterAddPieceEvent","text":"<pre><code>@dataclass(frozen=True)\nclass AfterAddPieceEvent(Event)\n</code></pre> <p>[view_source]</p> <p></p>"},{"location":"api-reference/square/#square-square","title":"square: <code>\"Square\"</code>","text":"<p>[view_source]</p> <p></p>"},{"location":"api-reference/square/#piece-piece","title":"piece: <code>\"Piece\"</code>","text":"<p>[view_source]</p> <p></p>"},{"location":"api-reference/square/#beforeaddpieceevent","title":"BeforeAddPieceEvent","text":"<pre><code>class BeforeAddPieceEvent(AfterAddPieceEvent)\n</code></pre> <p>[view_source]</p> <p></p>"},{"location":"api-reference/square/#set_piece","title":"set_piece","text":"<pre><code>def set_piece(piece: \"Piece\")\n</code></pre> <p>[view_source]</p> <p></p>"},{"location":"api-reference/square/#beforeremovepieceevent","title":"BeforeRemovePieceEvent","text":"<pre><code>@dataclass(frozen=True)\nclass BeforeRemovePieceEvent(Event)\n</code></pre> <p>[view_source]</p> <p></p>"},{"location":"api-reference/square/#square-square_1","title":"square: <code>\"Square\"</code>","text":"<p>[view_source]</p> <p></p>"},{"location":"api-reference/square/#piece-piece_1","title":"piece: <code>\"Piece\"</code>","text":"<p>[view_source]</p> <p></p>"},{"location":"api-reference/square/#afterremovepieceevent","title":"AfterRemovePieceEvent","text":"<pre><code>class AfterRemovePieceEvent(BeforeRemovePieceEvent)\n</code></pre> <p>[view_source]</p> <p></p>"},{"location":"api-reference/square/#square_event_types","title":"SQUARE_EVENT_TYPES","text":"<p>[view_source]</p> <p></p>"},{"location":"api-reference/square/#square","title":"Square","text":"<pre><code>@event_publisher(*SQUARE_EVENT_TYPES)\nclass Square(Cloneable,  EventPublisher)\n</code></pre> <p>[view_source]</p> <p></p>"},{"location":"api-reference/square/#__init__","title":"__init__","text":"<pre><code>def __init__(piece: Optional[\"Piece\"] = None)\n</code></pre> <p>[view_source]</p> <p></p>"},{"location":"api-reference/square/#piece","title":"piece","text":"<pre><code>@property\ndef piece() -&gt; \"Piece\"\n</code></pre> <p>[view_source]</p> <p></p>"},{"location":"api-reference/square/#position","title":"position","text":"<pre><code>@property\ndef position()\n</code></pre> <p>[view_source]</p> <p></p>"},{"location":"api-reference/square/#board","title":"board","text":"<pre><code>@property\ndef board()\n</code></pre> <p>[view_source]</p> <p></p>"},{"location":"api-reference/square/#piece_1","title":"piece","text":"<pre><code>@piece.setter\ndef piece(piece: \"Piece\")\n</code></pre> <p>[view_source]</p> <p></p>"},{"location":"api-reference/square/#clone","title":"clone","text":"<pre><code>def clone()\n</code></pre> <p>[view_source]</p>"},{"location":"guide/first-steps/","title":"First steps","text":"<p>Chess maker isn't designed around any specific chess rule or piece. This means any variant you make is a first-class citizen and should work just as fine as the standard game.</p> <p>This section covers the base concepts you'll have to learn in order to create these variants.</p> <p>However - you will probably not need to know all concepts in order to create a simple rule. It's recommended to skim through the concepts section, and then head to the tutorial that interests you.</p>"},{"location":"guide/concepts/base-game/","title":"Base Game","text":""},{"location":"guide/concepts/base-game/#introduction","title":"Introduction","text":"<p>Now that we've covered the more general concepts, we can start looking at the game itself.</p> <p>This section contains an overview of each concept, and tries to highlight useful methods, but it's not a complete reference - for that, you should look at the API Reference.</p>"},{"location":"guide/concepts/base-game/#game","title":"Game","text":"<p>The game class is a container for the board and the result function. It doesn't do much except for having an <code>AfterGameEndEvent</code> event that is published when the game ends.</p> <pre><code>game = Game(board, get_result)\ngame.subscribe(AfterGameEndEvent, lambda event: print(event.result))\n</code></pre>"},{"location":"guide/concepts/base-game/#result","title":"Result","text":"<p>The result function is a function that is called after every turn - it takes a board and returns either None or a string. There is no structure to the string - and it's used to tell the client what the result of the game is, but if the string returned is not None, the game will end.</p> <p>For a result function to have state (e.g. 50 move rule) it should be wrapped in a class that has a <code>__call__</code> method.</p> <pre><code>class GetDumbResult:\n    def __init__(self):\n        self.move_count = 0\n\n    def __call__(self, board: Board) -&gt; Optional[str]:\n        self.move_count += 1\n        if self.move_count &gt; 100:\n            return \"Draw - I'm bored\"\n        return None\n</code></pre>"},{"location":"guide/concepts/base-game/#board","title":"Board","text":"<p>The board is the main container for all squares. It also contains the players and the turn iterator.</p> <p>It's important to understand is that even though the board contains a turn iterator, it (or the Game itself) doesn't actually manage a game loop - it leaves that to any client.</p> <p>A board contains a 2D list of squares - these squares can be None (e.g. holes)  to create non-rectangular boards. When a square in the board changes (Not to confuse with when a piece changes) the board can publish <code>BeforeRemoveSquareEvent</code>, <code>AfterRemoveSquareEvent</code>, <code>BeforeAddSquareEvent</code> and <code>AfterAddSquareEvent</code>.</p> <p>The board also contains a list of players, and a turn iterator. The turn iterator is a generator that will be called to get the next player in the turn order. When this happens, the board publishes a <code>BeforeChangeTurnEvent</code> and <code>AfterChangeTurnEvent</code>.</p> <p>The board propagates all events from the squares and pieces it contains, which is very useful for subscribing to all of them at once. and also publishes <code>AfterNewPieceEvent</code> when a new piece is added to the board.</p> <p>It also contains a lot of utility methods for getting squares, pieces and players.</p> <pre><code>board = Board(squares, players, turn_iterator)\n\n# Get a square\nsquare = board[Position(0, 0)]\npiece = square.piece\n\nfor square in board:\n    print(square.position)\n\nfor y in board.size[1]:\n    for x in board.size[0]:\n        print(Position(x, y))\n\nfor player_piece in board.get_player_pieces(piece.player):\n    print(player_piece)\n</code></pre>"},{"location":"guide/concepts/base-game/#player","title":"Player","text":"<p>The player class is a simple container that is used to identify the owner of a piece. The name chosen is arbitrary - and doesn't have to be unique.</p> <pre><code>player0 = Player()\nplayer1 = Player(\"white\")\nplayer2 = Player(\"my_player2\")\n</code></pre>"},{"location":"guide/concepts/base-game/#position","title":"Position","text":"<p>A position is a named tuple that contains the x and y coordinates of a square or piece. <code>Position(0, 0)</code> is at the top left of the board.</p> <pre><code>position = Position(0, 0)\nprint(position)\nprint(position.x, position.y)\nprint(position[0], position[1])\n\nprint(position.offset(1, 1))\n</code></pre> <p>Info</p> <p>While both pieces and squares have a <code>position</code> attribute, it doesn't need to be changed manually. instead the board knows where each piece and square is, and the <code>position</code> attribute simply asks the board for its position.</p>"},{"location":"guide/concepts/base-game/#square","title":"Square","text":"<p>A square is a container for a piece. When setting a square's piece, it can publish <code>BeforeRemovePieceEvent</code>, <code>AfterRemovePieceEvent</code>, <code>BeforeAddPieceEvent</code> and <code>AfterAddPieceEvent</code>.</p> <p>The square has an (auto-updating) <code>position</code> attribute, and a <code>piece</code> attribute.</p> <pre><code>board = ...\nsquare = board[Position(0, 0)]\nprint(square.position, square.piece)\n\nsquare.subscribe(AfterAddPieceEvent, lambda event: print(event.piece))\n\nsquare.piece = Pawn(player0)\n</code></pre>"},{"location":"guide/concepts/base-game/#piece","title":"Piece","text":"<p>The piece is the main class in the base game that is meant to be extended. The piece is an abstract class, and must be extended to be used.</p> <p>A piece has an (immutable) <code>player</code> attribute, and an (auto-updating) <code>position</code> attribute. It also has a <code>name</code> class attribute, which is used for display purposes.</p> <p>The piece also has a <code>board</code> attribute, which is set when the piece is added to a board. Because the piece is created before it's added to the board, trying to access it when it's created will result in an error saying <code>Piece is not on the board yet</code>. To perform startup logic, the piece can implement an <code>on_join_board</code> method, which will be called when the piece is added to the board.</p> <p>Each piece has to implement a <code>_get_move_options</code> method, which returns an iterable of what moves the piece can make. Then, when the piece is asked for its move options, it will call the <code>_get_move_options</code> method and publish <code>BeforeGetMoveOptionsEvent</code> and <code>AfterGetMoveOptionsEvent</code> events.</p> <p>Then, a move option is selected by the user, and the piece is asked to make the move using <code>.move()</code> - which will publish <code>BeforeMoveEvent</code>, <code>AfterMoveEvent</code>, <code>BeforeCapturedEvent</code> and <code>AfterCapturedEvent</code> events.</p> <p>For a piece to implement moves that are more complex than just moving and capturing, it should subscribe to its own <code>BeforeMoveEvent</code> and <code>AfterMoveEvent</code> events, and implement the logic there.</p>"},{"location":"guide/concepts/base-game/#move-option","title":"Move Option","text":"<p>A MoveOption is used to describe a move that a piece can make. A move option has to specify the <code>position</code> it will move to with the <code>position</code> attribute, and all positions it will capture with the <code>captures</code> attribute.</p> <p>In addition, for special moves (e.g. castling, en passant) a move option can have an <code>extra</code> attribute, which is a dict. Ideally, this dict shouldn't contain complex objects like pieces or other dicts, but instead positions or other simple objects.</p> <pre><code>class CoolPiece(Piece):\n    \"\"\"\n    A piece that can move one square diagonally (down and right).\n    \"\"\"\n\n    @classmethod\n    @property\n    def name(cls):\n        return \"CoolPiece\"\n\n    def _get_move_options(self) -&gt; Iterable[MoveOption]:\n        move_position = self.position.offset(1, 1)\n\n        if not is_in_board(self.board, move_position):\n            return\n\n        if (self.board[move_position].piece is not None\n                and self.board[move_position].piece.player == self.player):\n            return\n\n        yield MoveOption(self.position, captures=[move_position])\n\n\nclass CoolerPiece(CoolPiece):\n    \"\"\"\n    A piece that can move one square diagonally (down and right) and turn into a Queen when capturing another cool piece.\n    \"\"\"\n    def __init__(self):\n        super().__init__()\n        # When listening to yourself, it's a good practice to use a high priority,\n        # to emulate being the default behavior of the piece.\n        self.subscribe(AfterMoveEvent, self._on_after_move, EventPriority.VERY_HIGH)\n\n    @classmethod\n    @property\n    def name(cls):\n        return \"CoolerPiece\"\n\n    def _get_move_options(self) -&gt; Iterable[MoveOption]:\n        move_options = super()._get_move_options()\n        for move_option in move_options:  \n            if isinstance(self.board[move_option.position].piece, CoolPiece):\n                move_option.extra = dict(turn_into_queen=True)\n                yield move_option\n\n    def _on_after_move(self, event: AfterMoveEvent):\n        if event.move_option.extra.get(\"turn_into_queen\"):\n            # To make this extendible, it's a good practice to send Before and After events for this \"promotion\".\n            self.board[event.move_option.position].piece = Queen(self.player)\n</code></pre>"},{"location":"guide/concepts/base-game/#rule","title":"Rule","text":"<p>A rule is a class that can be used to add custom logic to the game. It is also an abstract class, and must be extended to be used.</p> <p>Similarly to pieces, rules also have an <code>on_join_board</code> method - only that this one is required to implement, and gets the board as an argument. It should contain only startup logic (e.g. subscribing to events), and the board passed shouldn't be kept in state - instead, callbacks should use the board from the event (This is again related to cloneables, and will be explained in the next section).</p> <p>An <code>as_rule</code> method is provided to turn a function into a rule, which is useful for stateless rules.</p> <pre><code>def _on_after_move(event: AfterMoveEvent):\n    if isinstance(event.piece, King):\n        event.board.turn_iterator = chain(\n            [event.board.current_player],\n            event.board.turn_iterator,\n        )\n\ndef extra_turn_if_moved_king(board: Board):\n    board.subscribe(AfterMoveEvent, _on_after_move, EventPriority.HIGH)\n\nExtraTurnIfMovedKing = as_rule(extra_turn_if_moved_king)\n\n\nclass ExtraTurnIfMovedKingFirst(Rule):\n\n    def __init__(self):\n        self.any_king_moved = False\n\n\n    def _on_after_move(event: AfterMoveEvent):\n        if not self.any_king_moved and isinstance(event.piece, King):\n            event.board.turn_iterator = chain(\n                [event.board.current_player],\n                event.board.turn_iterator,\n            )\n            self.any_king_moved = True\n\n\n    def on_join_board(self, board: Board):\n        board.subscribe(BeforeMoveEvent, self._on_before_move, EventPriority.HIGH)\n\n\nboard = Board(\n    ...,\n    rules=[ExtraTurnIfMovedKing, ExtraTurnIfMovedKingFirst],\n)\n</code></pre>"},{"location":"guide/concepts/cloneables/","title":"Cloneables","text":""},{"location":"guide/concepts/cloneables/#introduction","title":"Introduction","text":"<p>While ChessMaker isn't dependent on any specific chess rule or piece, there some concepts that are mainly used by one piece in the standard game.</p> <p>One of these is that everything in the board (e.g. everything besides the Game object) has a <code>clone</code> method, which returns a copy of the object.</p> <p>In the standard game, this is only used for the King implementation (Though it could be useful for other custom rules too) - so while most your rules and pieces won't have to use the clone method, they all have to implement it.</p> Info <p>Because a game doesn't have to include a king, other pieces aren't aware of the concepts of check and checkmate. This means the king subscribes to <code>BeforeGetMoveOptionsEvent</code> events of all pieces, and checks if any of those moves would make it attacked by simulating the move in a cloned board. Simulation is necessary because of custom rules. For example - a custom piece could theoretically define that if the King moved near it - it would turn into a queen. This means just looking at the move options and not actually moving the piece would cause incorrect results.</p>"},{"location":"guide/concepts/cloneables/#what-is-cloneable","title":"What is Cloneable?","text":"<ul> <li>The board</li> <li>Squares</li> <li>Pieces</li> <li>Rules</li> </ul> <p>The board and squares don't really interest us, since they aren't meant to be extended. So let's focus on pieces and rules.</p>"},{"location":"guide/concepts/cloneables/#pieces","title":"Pieces","text":""},{"location":"guide/concepts/cloneables/#stateless-pieces","title":"Stateless pieces","text":"<p>Even stateless pieces have to implement the clone method - while this could be implemented by the base piece class, making all pieces do it makes it harder to forget when  implementing a stateful piece. The is how it would look:</p> <pre><code>class CoolPiece(Piece):\n    def clone(self):\n        return CoolPiece(self.player)\n</code></pre>"},{"location":"guide/concepts/cloneables/#stateful-pieces","title":"Stateful pieces","text":"<p>The simplest example for this is the Rook. While the Rook is a fairly simple piece, it has to know if it has moved or not. This is because it can only castle if it hasn't moved yet.</p> <pre><code>class Rook(Piece):\n    def __init__(self, player, moved=False):\n        super().__init__(player)\n        self._moved = moved\n\n    # Some rook logic...\n\n    def clone(self):\n        return Rook(self.player, self._moved)\n</code></pre>"},{"location":"guide/concepts/cloneables/#inheriting-from-other-pieces","title":"Inheriting from other pieces","text":"<p>If you're inheriting from another piece, you should reimplement the clone method. <pre><code>class CoolerPiece(CoolPiece):\n    def clone(self):\n        return CoolerPiece(self.player)\n</code></pre></p>"},{"location":"guide/concepts/cloneables/#rules","title":"Rules","text":"<p>For rules, it's about the same - but a bit easier.</p>"},{"location":"guide/concepts/cloneables/#stateless-rules","title":"Stateless rules","text":"<p>If your rule doesn't have any state, it should be a function that uses the <code>as_rule</code> helper function anyway - so you don't have to implement the clone method.</p> <pre><code>def my_simple_rule(board: Board):\n    # Some rule logic...\n\nMySimpleRule = as_rule(my_simple_rule)\n</code></pre>"},{"location":"guide/concepts/cloneables/#stateful-rules","title":"Stateful rules","text":"<p>If your rule has state, you should implement the clone method.</p> <pre><code>class ExtraTurnOnFirstKingMove(Rule):\n\n    def __init__(self, player_king_moved: dict[Player, bool] = None):\n        if player_king_moved is None:\n            player_king_moved = defaultdict(bool)\n        self.player_king_moved: dict[Player, bool] = player_king_moved\n\n\n    def _on_after_move(event: AfterMoveEvent):\n        if not self.player_king_moved[event.piece.player] and isinstance(event.piece, King):\n            event.board.turn_iterator = chain(\n                [event.board.current_player],\n                event.board.turn_iterator,\n            )\n            self.player_king_moved[event.piece.player] = True\n\n\n    def on_join_board(self, board: Board):\n        board.subscribe(AfterMoveEvent, self._on_after_move, EventPriority.HIGH)\n\n\n    def clone(self):\n        return ExtraTurnOnFirstKingMove(self.player_king_moved.copy())\n</code></pre>"},{"location":"guide/concepts/cloneables/#why-not-just-deepcopy","title":"Why not just deepcopy?","text":"<p>If you're wondering why ChessMaker doesn't just use <code>copy.deepcopy</code> - it's because deepcopy would copy all attributes, including event subscriptions - which is not what we want.</p>"},{"location":"guide/concepts/events/","title":"Events","text":""},{"location":"guide/concepts/events/#introduction","title":"Introduction","text":"<p>ChessMaker uses a custom event system to allow altering and extending the game logic.  This allows you to add custom logic to the game without having to modify the engine code.</p> <p>The event system is inspired by Spigot's Event API.</p>"},{"location":"guide/concepts/events/#events_1","title":"Events","text":"<p>The event system defines a base <code>Event</code> dataclass that all event types inherit from. All attributes of the event are immutable by default, and the event exposes one function called _set, which allows event types to make a specific attribute mutable.</p> <p>Generally, things that happen expose a before and after event, with some only exposing an after event. A common pattern is for after events to be completely immutable, and for before events to have mutable attributes.</p> <pre><code>from dataclasses import dataclass\nfrom chessmaker.events import Event\nfrom chessmaker.chess.base.move_option import MoveOption\n\n# An immutable event\n@dataclass(frozen=True)\nclass AfterMoveEvent(Event):\n    piece: \"Piece\"\n    move_option: MoveOption\n\n# A mutable event\nclass BeforeMoveEvent(AfterMoveEvent):\n    def set_move_option(self, move_option: MoveOption):\n        self._set(\"move_option\", move_option)\n</code></pre>"},{"location":"guide/concepts/events/#cancellable-events","title":"Cancellable Events","text":"<p>Events can also inherit from the <code>CancellableEvent</code> class,  which adds a <code>cancelled</code> attribute and a <code>set_cancelled</code> function to the event.</p> <pre><code>from chessmaker.events import CancellableEvent\n\nclass BeforeMoveEvent(AfterMoveEvent, CancellableEvent):\n    def set_move_option(self, move_option: MoveOption):\n        self._set(\"move_option\", move_option)\n</code></pre> <p>Note</p> <p>Most of the time, you're going to be subscribing to existing events, but if you are creating a new event, you should remember events are just dataclasses - and don't actually implement logic like cancelling or mutating.  It is the publisher's responsibility to use the mutated event in the correct way.</p>"},{"location":"guide/concepts/events/#subscribing-to-events","title":"Subscribing to events","text":"<p>To subscribe to events, you need to subscribe to a publisher with the event type and callback function. Events are subscribed to on a per-instance basis - when you subscribe to a Pawn moving, it will only subscribe to that specific pawn - not all pawns.</p> <pre><code>import random\n\nboard: Board = ...\n\ndef on_after_turn_change(event: BeforeTurnChangeEvent):\n    if random.random() &lt; 0.5:\n        event.set_cancelled(True)\n    else:\n        event.set_next_player(event.board.players[1])\n\n\n\nboard.subscribe(BeforeTurnChangeEvent, on_after_turn_change)\n</code></pre> <p>Tip</p> <p>In you event's callback function, you should use the arguments from the event, rather than using ones from your outer scope (For example, <code>board</code> in the above example). This is related to Cloneables, and will be explained later.</p>"},{"location":"guide/concepts/events/#event-priorities","title":"Event Priorities","text":"<p>Events can be subscribed to with a priority, which determines the order in which they are called - a higher priority means the event is called earlier.</p> <p>For most use cases, the default priority of <code>0</code> is fine, but if you need to ensure your event is called before or after another event, you can either use the <code>EventPriority</code> enum to specify a priority, or use an integer for more fine-grained control.</p> <pre><code>from chessmaker.events import EventPriority\n\nboard.subscribe(BeforeTurnChangeEvent, on_after_turn_change)\nboard.subscribe(BeforeTurnChangeEvent, on_after_turn_change, priority=EventPriority.VERY_LOW)\nboard.subscribe(BeforeTurnChangeEvent, on_after_turn_change, 2000)\n</code></pre>"},{"location":"guide/concepts/events/#subscribing-to-all-events-of-an-instance","title":"Subscribing to all events of an instance","text":"<p>You can also subscribe to all events of an instance by using the <code>subscribe_all</code> function.</p> <pre><code>def on_any_event(_: Event):\n    print(\"Something happened to the board!\")\n\nboard.subscribe_all(on_any_event)\n</code></pre>"},{"location":"guide/concepts/events/#unsubscribing-from-events","title":"Unsubscribing from events","text":"<p>To unsubscribe from events, you need to call the <code>unsubscribe</code> function with the same arguments you used to subscribe. Similarly, you can use <code>unsubscribe_all</code> to unsubscribe from all events of an instance.</p> <pre><code>board.unsubscribe(BeforeTurnChangeEvent, on_after_turn_change)\nboard.unsubscribe_all(on_any_event)\n</code></pre>"},{"location":"guide/concepts/events/#publishing-events","title":"Publishing events","text":"<p>If you're adding new code, and want to make that code extendible - it is recommended to publish events. For an instance to publish events, it needs to use the <code>@event_publisher</code> decorator, and specify the event types it publishes.</p> <p>If it inherits from another publisher, you need use the same decorator to specify the additional event types it publishes, If it doesn't publish any additional events, you don't have to use the decorator at all.</p> <p>For typing and completion purposes, a publisher should also inherit from <code>EventPublisher</code>. (If it doesn't inherit from another publisher).</p> <pre><code>from chessmaker.events import EventPublisher, event_publisher\n\n@event_publisher(BeforePrintEvent, AfterPrintEvent)\nclass MyPrinter(EventPublisher):\n\n    def print_number(self):\n        number = str(random.randint(0, 100))\n        before_print_event = BeforePrintEvent(self, number)\n        self.publish(before_print_event)\n        if not before_print_event.cancelled:\n            print(before_print_event.number)\n            self.publish(AfterPrintEvent(self, number))\n</code></pre>"},{"location":"guide/concepts/events/#propagating-events","title":"Propagating events","text":"<p>Sometimes, you may want to publish events from a publisher to another one. You can do this either to all event types, or to a specific one.</p> <pre><code>@event_publisher(BeforePrintEvent, AfterPrintEvent)\nclass MyPrinterManager(EventPublisher):\n\n    def __init__(self, my_printer: MyPrinter):\n        self.my_printer = my_printer\n        self.my_printer.propagate_all(self)\n        self.my_printer.propagate(BeforePrintEvent, self)\n</code></pre> <p>Now, every time the printer publishes an event, the manager will also publish it. Currently, you can not unpropagate events.</p> <p>Info</p> <p>The main use of this in the game is the board propagating all events of its pieces and squares to itself. This means that instead of subscribing to a specific piece move, you can subscribe to all pieces moving by subscribing to the board.</p>"},{"location":"guide/tutorials/capture-all-pieces-to-win/","title":"Capture All Pieces to Win","text":""},{"location":"guide/tutorials/capture-all-pieces-to-win/#introduction","title":"Introduction","text":"<p>Out of all custom rules we'll cover, this is probably the simplest one.</p> <p>We're going to create a new result function - <code>capture_all_pieces_to_win</code>, it accepts a board and returns a descriptive string if the game is over - otherwise it returns <code>None</code>.</p>"},{"location":"guide/tutorials/capture-all-pieces-to-win/#creating-the-result-function","title":"Creating the result function","text":"capture_all_pieces_to_win.py<pre><code>from chessmaker.chess.base import Board\n\n\ndef capture_all_pieces_to_win(board: Board) -&gt; str | None: \n    lost_players = []\n    for player in board.players: \n        if len(list(board.get_player_pieces(player))) == 0: # (1)\n            lost_players.append(player)\n\n    if len(lost_players) == 0: # (2)\n        return None\n\n    if len(lost_players) == 1: # (3)\n        return f\"All pieces captured - {lost_players[0].name} loses\"\n\n    return \"Multiple players have no pieces - Draw\" # (4)\n</code></pre> <ol> <li>We check if the player has any pieces left.</li> <li>If no players have lost, the game is not over - we return <code>None</code>.</li> <li>If only one player has no pieces, we return a string saying that they have lost. We specifically check for 1 player to support a custom rule that could allow a piece to destroy itself - causing both players to have no pieces left.</li> <li>If both players have no pieces, we return a string saying that the game is a draw.</li> </ol> <p>Then, when we create a new game, we can pass this function to the <code>result_function</code> argument:</p> <pre><code>game = Game(\n    board=...,\n    get_result=capture_all_pieces_to_win,\n)\n</code></pre> <p>And that's it! We can now play a game where the only winning condition is to capture all pieces.</p>"},{"location":"guide/tutorials/capture-all-pieces-to-win/#adding-other-result-functions","title":"Adding other result functions","text":"<p>Even though we don't want to be able to win by checkmate in this variant, we might still want to have stalemate, repetition and other result functions.</p> <p>To do this, we can change our result function to a class, and add in other results:</p> <pre><code>from chessmaker.chess.results import stalemate, Repetition, NoCapturesOrPawnMoves\n\nclass CaptureAllPiecesToWin:\n    def __init__(self):\n        self.result_functions = [capture_all_pieces_to_win, stalemate, Repetition(), NoCapturesOrPawnMoves()]\n\n    def __call__(self, board: Board):\n        for result_function in self.result_functions:\n            result = result_function(board)\n            if result:\n                return result\n</code></pre> <p>Note</p> <p>Results that hold state (like repitition or compuond results like ours) should always be classes (and not functions), so they can be copied.</p>"},{"location":"guide/tutorials/capture-all-pieces-to-win/#removing-checks","title":"Removing checks","text":"<p>For a game mode like this, starting with a king is not required (though it's still possible to do so).</p> <p>However, if we would want to start with a king that can't be checked, we would have to change some more things when initializing the board.</p> <p>Thankfully, the default King implementation supports an <code>attackable</code> argument (which defaults to False), so we can just set it to true:</p> <pre><code>_king = lambda player: King(player, attackable=True)\n\ngame = Game(\n    board=Board(\n        squares=[\n            [Square(_king(black)), ...],\n            ...\n        ],  \n        ...\n    )\n    get_result=capture_all_pieces_to_win,\n)\n</code></pre> What if the king didn't have an <code>attackable</code> argument? <p>In this case, it was convenient that the King class had an <code>attackable</code> argument (for another purpose), but how would we implement this if it didn't? Because a custom king implementation is a lot of work, we could just inherit from the default King class. It would require looking a bit at the source code - but we would quickly see the startup logic for the King's check handling is done in <code>on_join_board</code>, so we would just override it: <pre><code>def AttackableKing(King):\n    def on_join_board(self, board: Board):\n        pass\n</code></pre></p>"},{"location":"guide/tutorials/forced-en-passant/","title":"Forced En Passant","text":""},{"location":"guide/tutorials/forced-en-passant/#introduction","title":"Introduction","text":"<p>This rule is pretty simple to define, and it works similarly to how the king works. When a certain condition is met, we force all the player's pieces to make only specific moves.</p> <p>In the king's case, the condition is that the king can't be attacked. And in our case, the condition is that the player can en passant.</p>"},{"location":"guide/tutorials/forced-en-passant/#structuring-the-rule","title":"Structuring the Rule","text":"<p>After a turn changed:</p> <ul> <li> <p>For all</p> <ul> <li>Pawns of a player.</li> </ul> </li> <li> <p>We need to</p> <ul> <li>Check if the pawn can en passant.</li> </ul> </li> </ul> <p>And if any of the pawns can:</p> <ul> <li> <p>For all</p> <ul> <li>Pieces of the same player.</li> </ul> </li> <li> <p>We need to</p> <ul> <li>Remove all moves that aren't en passant.</li> </ul> </li> </ul> forced_en_passant.py<pre><code>from collections import defaultdict\n\nfrom chessmaker.chess.base.board import Board\nfrom chessmaker.chess.base.game import AfterTurnChangeEvent\nfrom chessmaker.chess.base.piece import BeforeGetMoveOptionsEvent\nfrom chessmaker.chess.base.player import Player\nfrom chessmaker.chess.base.rule import Rule\nfrom chessmaker.events import EventPriority\n\nclass ForcedEnPassant(Rule):\n    def __init__(self, can_en_passant: dict[Player, bool] = None):\n        if can_en_passant is None:\n            can_en_passant = defaultdict(lambda: False)\n        self.can_en_passant: dict[Player, bool] = can_en_passant\n\n    def on_join_board(self, board: Board):\n        board.subscribe(BeforeGetMoveOptionsEvent, self.on_before_get_move_options, EventPriority.LOW)\n        board.subscribe(AfterTurnChangeEvent, self.on_turn_change)\n\n    def on_turn_change(self, event: AfterTurnChangeEvent):\n        pass\n\n    def on_before_get_move_options(self, event: BeforeGetMoveOptionsEvent):\n        pass\n\n    def clone(self):\n        return ForcedEnPassant(can_en_passant=self.can_en_passant.copy())\n</code></pre>"},{"location":"guide/tutorials/forced-en-passant/#implementing-the-rule","title":"Implementing the Rule","text":"<p>Here too, use the annotations to help you understand what's going on.</p>"},{"location":"guide/tutorials/forced-en-passant/#checking-if-any-pawn-can-en-passant","title":"Checking if any pawn can en passant","text":"<pre><code>from chessmaker.chess.pieces import Pawn\n\n  def on_turn_change(self, event: AfterTurnChangeEvent):\n      for player in event.board.players: # (1)\n          self.can_en_passant[player] = False\n\n          for piece in event.board.get_player_pieces(player): \n\n              if isinstance(piece, Pawn): # (2)\n                  move_options = piece.get_move_options()\n\n                  if any(move_option.extra.get(\"en_passant\") for move_option in move_options): # (3)\n                      self.can_en_passant[player] = True\n                      break # (4)\n</code></pre> <ol> <li>For each player.</li> <li>For each pawn of the player.</li> <li>If any of the pawn's move options is an en passant.</li> <li>If any of the player's pawns can en passant, we don't need to check the other pawns.</li> </ol>"},{"location":"guide/tutorials/forced-en-passant/#removing-all-other-move-options","title":"Removing all other move options","text":"<pre><code>from chessmaker.chess.base.piece import BeforeGetMoveOptionsEvent\n\n  def on_before_get_move_options(self, event: BeforeGetMoveOptionsEvent):\n      if self.can_en_passant[event.piece.player]: # (1)\n          move_options = []\n          for move_option in event.move_options: \n              if move_option.extra.get(\"en_passant\"): # (2)\n                  move_options.append(move_option)\n          event.set_move_options(move_options) # (3)\n</code></pre> <ol> <li>If the player can en passant.</li> <li>Keep only the move options that are en passant.</li> <li>Set the move options to the new list.</li> </ol>"},{"location":"guide/tutorials/forced-en-passant/#finishing-up","title":"Finishing Up","text":"<p>Now that we've implemented our rule, we can add it to the board:</p> <pre><code>board = Board(\n    ...\n    rules=[ForcedEnPassant()]\n)\n</code></pre> <p>And that's it! We've implemented a rule that makes en passant forced when it's possible.  Let's see it in action:</p> <p></p>"},{"location":"guide/tutorials/knook/","title":"Knook","text":""},{"location":"guide/tutorials/knook/#introduction","title":"Introduction","text":"<p>A Knook is a new piece that can move both like a knight and a rook. It is created by merging a knight and a rook of the same player.</p> <p>While this rule could be implemented with 1 new piece and a 1 new rule, We're going to implement it with 3 new pieces and no rules -  to demonstrate the flexibility of creating new variants.</p> <p>The first thing we need to do is create the Knook piece. Then, we'll add a way for the knight and the rook to be merged into one.</p> <p>Tip</p> <p>If you're just looking for how to create a new piece, don't be scared by the length of this tutorial. Most of it is just for the merging.</p>"},{"location":"guide/tutorials/knook/#the-knook-itself","title":"The Knook Itself","text":""},{"location":"guide/tutorials/knook/#implementing-the-piece","title":"Implementing the Piece","text":"<p>The Knook can move like a knight and a rook. We can ue functions in <code>piece_utils</code> to help us implement this.</p> knook.py<pre><code>from functools import partial\nfrom typing import Iterable\n\nfrom chessmaker.chess.base.move_option import MoveOption\nfrom chessmaker.chess.base.piece import Piece\nfrom chessmaker.chess.piece_utils import filter_uncapturable_positions, is_in_board, \\\n    get_straight_until_blocked, positions_to_move_options\n\nMOVE_OFFSETS = [(1, 2), (2, 1), (2, -1), (1, -2), (-1, -2), (-2, -1), (-2, 1), (-1, 2)] # (1)\n\nclass Knook(Piece):\n    @classmethod\n    @property\n    def name(cls):\n        return \"Knook\" # (2)\n\n    def _get_move_options(self) -&gt; Iterable[MoveOption]: # (3)\n        positions = [self.position.offset(*offset) for offset in MOVE_OFFSETS] \n        positions = filter(partial(is_in_board, self.board), positions)\n        positions = filter_uncapturable_positions(self, positions) # (4)\n\n        positions += filter_uncapturable_positions(self,\n            get_straight_until_blocked(self)\n        ) # (5)\n\n        return positions_to_move_options(self.board, positions) # (6)\n\n    def clone(self):\n        return Knook(self.player)\n</code></pre> <ol> <li>We could have also used the knight's <code>MOVE_OFFSETS</code> constant.</li> <li>The name of the piece is used for display purposes, and it's a class property.</li> <li>The <code>_get_move_options</code> method is called when the piece is asked for its move options.    It returns an iterable of <code>MoveOption</code> objects.</li> <li>We get all of a Knight's move options, filter out the ones that are out of the board,    and filter out the ones that are blocked by a piece of the same player.</li> <li>We add all of a Rook's move options, and filter out the ones that are blocked by a piece of the same player.</li> <li>We return the move options as a list of <code>MoveOption</code> objects. The <code>positions_to_move_options</code>    function is a helper function adds the <code>captures</code> argument if the position is occupied by    a piece.</li> </ol>"},{"location":"guide/tutorials/knook/#making-it-displayable","title":"Making it displayable","text":"<p>The UI is independent of the game logic. And theoretically, you could use any UI you want. However, since ChessMaker is packaged with a UI, this tutorial will also show how to add the Knook to it.</p> <p>The <code>start_pywebio_chess_server</code> function accepts an optional PIECE_URLS argument. The argument is a dictionary where the keys are the names of the pieces, and the values are tuples of URLs, with as many amount of players you want to support.</p> <p>The <code>pywebio_ui</code> also exposes a <code>PIECE_URLS</code> constant, which is a dictionary of the default pieces. We can use it to create a new dictionary with the Knook.</p> main.py<pre><code>from chessmaker.clients.pywebio_ui import start_pywebio_chess_server, PIECE_URLS\n\nif __name__ == \"__main__\":\n    start_pywebio_chess_server(\n        create_game,\n        piece_urls=PIECE_URLS | {\"Knook\": (\"https://i.imgur.com/UiWcdEb.png\", \"https://i.imgur.com/g7xTVts.png\")}\n    )\n</code></pre> <p>And that's it for the new piece! If we didn't want to have the piece created by merging, this would be very simple. However, we have some more work to do.</p>"},{"location":"guide/tutorials/knook/#implementing-merging","title":"Implementing merging","text":"<p>Now that we have the Knook, we need to implement a way to create it by merging a knight and a rook.</p> <p>As mentioned before, this is possible to do by creating a new rule, but for the sake of this tutorial, we'll implement it with 2 new pieces. We'll create a <code>KnookableKnight</code> and a <code>KnookableRook</code>.</p> <p>Because both the new knight and the new rook need to have similar logic (yet not identical), we'll create a few helper functions that will be used by both pieces.</p>"},{"location":"guide/tutorials/knook/#knookable","title":"Knookable","text":"<p>First, we'll define an empty interface called <code>Knookable</code> that will let a mergeable piece know that it can be merge with another piece.</p> <pre><code>class Knookable:\n    pass\n</code></pre>"},{"location":"guide/tutorials/knook/#getting-the-merge-move-options","title":"Getting the merge move options","text":"<p>Then, we'll create a helper function that will return move options that are available for merging.</p> <p>The idea is that a piece will provide where it can move to, and the merge move options will return the MoveOptions that are occupied by a piece that it can be merged with it, along with extra information about the merge in the move option, so that the merge can be done later.</p> <pre><code>from typing import Iterable\n\nfrom chessmaker.chess.base.move_option import MoveOption\nfrom chessmaker.chess.base.piece import Piece\nfrom chessmaker.chess.base.position import Position\nfrom chessmaker.chess.pieces.knook.knookable import Knookable\n\n\ndef get_merge_move_options(piece: Piece, positions: Iterable[Position]) -&gt; Iterable[MoveOption]:\n    for position in positions:\n        position_piece = piece.board[position].piece\n\n        if position_piece is not None and position_piece.player == piece.player: # (1)\n            if isinstance(position_piece, Knookable) and not isinstance(position_piece, type(piece)): # (2)\n                yield MoveOption(position, extra=dict(knook=True)) # (3)\n</code></pre> <ol> <li>We only want to merge with pieces of the same player.</li> <li>We only want to merge with pieces that are Knookable, and not the same type as the piece    (e.g. we can't merge a knight with another knight).</li> <li>We return a move option with the <code>knook</code> extra argument set to <code>True</code>,    so that we can later easily know that this move option is for merging.</li> </ol>"},{"location":"guide/tutorials/knook/#performing-the-merge","title":"Performing the merge","text":"<p>We'll create another helper function that will perform the merge, given an <code>AfterMoveEvent</code> event - and both of our new pieces will subscribe to it with that function.</p> <p>To make our rule extendible, we'll also publish events when a merge occurs - but because these are new events that are not part of the core game, it's up to us how and what to publish.</p> <pre><code>from dataclasses import dataclass\n\nfrom chessmaker.chess.base.piece import Piece, AfterMoveEvent\nfrom chessmaker.chess.pieces.knook.knook import Knook\nfrom chessmaker.events import Event\n\n@dataclass(frozen=True)\nclass AfterMergeToKnookEvent(Event):\n    piece: Piece # (1)\n    knook: Knook\n\n\nclass BeforeMergeToKnookEvent(AfterMergeToKnookEvent):\n    def set_knook(self, knook: Knook): # (2)\n        self._set(\"knook\", knook) # (3)\n\ndef on_after_move(event: AfterMoveEvent): # (4)\n    if event.move_option.extra.get(\"knook\"): # (5)\n        piece = event.piece\n        before_merge_to_knook_event = BeforeMergeToKnookEvent(\n            piece,\n            Knook(event.piece.player)\n        ) # (6)\n        event.piece.publish(before_merge_to_knook_event)\n\n        knook = before_merge_to_knook_event.knook # (7)\n        piece.board[event.move_option.position].piece = knook # (8)\n\n        piece.publish(AfterMergeToKnookEvent(piece, knook))\n</code></pre> <ol> <li>Because of how we implemented this, we're not able to provide both the    rook and the knight in the event, so we just provide the piece that    initiated the merge. This isn't a problem, because this is our own event.</li> <li>We create a <code>BeforeMergeToKnookEvent</code> event that will allow subscribers to    change the <code>Knook</code> object that will be created.</li> <li>We use the <code>Event</code>s <code>_set</code> method to change the <code>knook</code> attribute,    which can't be changed regularly (because we want the rest of the event to be immutable).</li> <li>We're subscribing to the <code>AfterMoveEvent</code> event - meaning at the time    this function is called, the initiating piece has moved to the piece it    wants to merge with - which is now not on the board anymore. Now we just    have to change the piece on the new position to a <code>Knook</code>.</li> <li>We check if the move option has the <code>knook</code> extra argument set to <code>True</code>.</li> <li>We create the <code>BeforeMergeToKnookEvent</code> event in a separate variable,    so that we can still access it after we publish it.</li> <li>We get the <code>knook</code> object from the event, so that subscribers can change it.</li> <li>Finally, we change the piece on the new position to a knook.</li> </ol>"},{"location":"guide/tutorials/knook/#the-new-pieces","title":"The new pieces","text":"<p>A tricky part here is that it's very tempting to think we can just pass the Knight and Rook's move options to the <code>get_merge_move_options</code> -  but in fact, those move options already filtered out positions where there's a piece of the same player, so we'll have to re-create the move options partially.</p> <p>We'll still want to inherit from the Knight and Rook, so that pieces which check for the type of the piece (using <code>isinstance</code>) will still work.</p> <p>The annotations here will only be for the <code>KnookableKnight</code> class, since it's about the same for both.</p> <pre><code>from functools import partial\nfrom itertools import chain\nfrom typing import Iterable\n\nfrom chessmaker.chess.base.move_option import MoveOption\nfrom chessmaker.chess.base.piece import AfterMoveEvent\nfrom chessmaker.chess.base.player import Player\nfrom chessmaker.chess.pieces import knight\nfrom chessmaker.chess.pieces.knight import Knight\nfrom chessmaker.chess.pieces.knook.knookable import Knookable\nfrom chessmaker.chess.piece_utils import is_in_board, get_straight_until_blocked\nfrom chessmaker.chess.pieces.rook import Rook\nfrom chessmaker.chess.pieces.knook.merge_to_knook import get_merge_move_options, merge_after_move, \\\n    MERGE_TO_KNOOK_EVENT_TYPES\nfrom chessmaker.events import EventPriority, event_publisher\n\n\n@event_publisher(*MERGE_TO_KNOOK_EVENT_TYPES) # (1)\nclass KnookableKnight(Knight, Knookable):\n    def __init__(self, player):\n        super().__init__(player)\n        self.subscribe(AfterMoveEvent, merge_after_move, EventPriority.VERY_HIGH) # (2)\n\n    def _get_move_options(self):\n        positions = [self.position.offset(*offset) for offset in knight.MOVE_OFFSETS] # (3)\n        positions = list(filter(partial(is_in_board, self.board), positions))\n        merge_move_options = get_merge_move_options(self, positions) # (4)\n\n        return chain(super()._get_move_options(), merge_move_options) # (5)\n\n    def clone(self):\n        return KnookableKnight(self.player)\n\n\n\n@event_publisher(*MERGE_TO_KNOOK_EVENT_TYPES)\nclass KnookableRook(Rook, Knookable):\n    def __init__(self, player: Player, moved: bool = False):\n        super().__init__(player, moved)\n        self.subscribe(AfterMoveEvent, merge_after_move, EventPriority.VERY_HIGH)\n\n    def _get_move_options(self) -&gt; Iterable[MoveOption]:\n        positions = list(get_straight_until_blocked(self))\n        merge_move_options = get_merge_move_options(self, positions)\n\n        return chain(super()._get_move_options(), merge_move_options)\n\n    def clone(self):\n        return KnookableRook(self.player, self.moved)\n</code></pre> <ol> <li>While it's clear that we need to inherit from <code>Knight</code> and <code>Knookable</code>,    we also want to inherit from <code>EventPublisher</code> - because we want to specify    we're publishing more events than the base <code>Piece</code> class. This isn't    necessary, but it's good practice.</li> <li>We subscribe to the <code>AfterMoveEvent</code> with the helper function we created    earlier. It's a good practice to set the priority to <code>VERY_HIGH</code> when subscribing     to your own events, because you want all other subscribers to have the changes    you make.</li> <li>If we didn't know the knight's <code>MOVE_OFFSETS</code> constant, we would just create    our own.</li> <li>We get the positions the knight can move to, without filtering positions    where there's a piece of the same player, and instead filter them    (and convert to move options) using the <code>get_merge_move_options</code> function.</li> <li>We add the move options from the <code>get_merge_move_options</code> function to the    move options from the <code>Knight</code> class. We could have also just created    the Knight's move options, since we already did some of the work needed for it.</li> </ol>"},{"location":"guide/tutorials/knook/#finishing-up","title":"Finishing up","text":"<p>Now that we have both our new pieces, we're almost done! We just need to create a board that uses our Knookable pieces. It's also important to remember to use it in other references to Knight and Rook  in the board creation, such as in promotion - otherwise the promotion will create an unmergeable piece.</p> <pre><code>board = Board(\n    squares=[\n        [KnookableRook(black), KnookableKnight(black), ...],\n        [Pawn(black, Pawn.Direction.DOWN, promotions=[KnookableKnight, KnookableRook, ...])],\n        ...\n    ],\n    ...\n)\n</code></pre> <p>And that's it! We now have a fully functional chess game with a new piece. Let's see it in action:</p> <p></p>"},{"location":"guide/tutorials/omnipotent-f6-pawn/","title":"Omnipotent F6 Pawn","text":""},{"location":"guide/tutorials/omnipotent-f6-pawn/#introduction","title":"Introduction","text":"<p>For this rule, we're going to implement something quite special.</p> <p>The Omnipotent F6 Pawn rule is another rule that originated from r/AnarchyChess. Without getting into it's history, the rule makes it so that if the enemy has a piece on the F6 square, then a pawn can be summoned there instead.</p>"},{"location":"guide/tutorials/omnipotent-f6-pawn/#designing-the-rule","title":"Designing the Rule","text":"<p>Creating a rule like this is tricky. It challenges some assumptions that we've made like that each move belongs to a piece. Luckily, ChessMaker's flexibility allows us to implement this rule without breaking any of the assumptions.</p> <p>What we're going to do is make it so each piece has an extra move option that summons a pawn to the F6 square - and doesn't affect the piece itself.</p> <p>We'll do this by using the <code>BeforeMoveEvent.set_cancelled()</code> method. We'll cancel the move, and instead summon a pawn to the F6 square (and publish events for it as if it was a regular move).</p>"},{"location":"guide/tutorials/omnipotent-f6-pawn/#structuring-the-rule","title":"Structuring the Rule","text":"<p>So, we want to add a move option to all pieces, and use <code>BeforeMoveEvent</code> once any piece has moved with that move option to cancel the move and summon a pawn instead.</p> <ul> <li> <p>For all</p> <ul> <li>Pieces in the board</li> </ul> </li> <li> <p>We need to</p> <ul> <li>Add a move option to the piece</li> <li>Before the piece moves, alter the move option to summon a pawn instead.</li> </ul> </li> </ul> omnipotent_f6_pawn.py<pre><code>from typing import Callable\n\nfrom chessmaker.chess.base.board import Board\nfrom chessmaker.chess.base.piece import BeforeGetMoveOptionsEvent, BeforeMoveEvent\nfrom chessmaker.chess.base.player import Player\nfrom chessmaker.chess.base.position import Position\nfrom chessmaker.chess.base.rule import Rule\nfrom chessmaker.chess.pieces import Pawn\nfrom chessmaker.events import EventPriority\n\nF6 = Position(5, 2) # (1)\n\n\nclass OmnipotentF6Pawn(Rule):\n    def __init__(self, pawn: Callable[[Player], Pawn]):\n        self._pawn = pawn # (2)\n\n    def on_join_board(self, board: Board):\n        board.subscribe(BeforeGetMoveOptionsEvent, self.on_before_get_move_options, EventPriority.HIGH)\n        board.subscribe(BeforeMoveEvent, self.on_before_move)\n\n    def on_before_get_move_options(self, event: BeforeGetMoveOptionsEvent):\n        pass\n\n    def on_before_move(self, event: BeforeMoveEvent):\n        pass\n\n\n    def clone(self):\n        return OmnipotentF6Pawn(pawn=self._pawn)\n</code></pre> <ol> <li>Notice that while chess notation numbers positions from the bottom left, ChessMaker    numbers them from the top left. This is because the squares are a 2D array - and    the first index is the row, and the second is the column.</li> <li>The reason we're not using the <code>Pawn</code> class directly is that because it    accepts more arguments that we don't have - like the pawn's direction    and what it can promote to.</li> </ol>"},{"location":"guide/tutorials/omnipotent-f6-pawn/#implementing-the-rule","title":"Implementing the Rule","text":"<p>Again, use the annotations to help you understand what's going on.</p>"},{"location":"guide/tutorials/omnipotent-f6-pawn/#adding-the-move-option","title":"Adding the Move Option","text":"<pre><code>from itertools import chain\nfrom chessmaker.chess.base.move_option import MoveOption\n\n\ndef on_before_get_move_options(self, event: BeforeGetMoveOptionsEvent):\n    f6_piece = event.piece.board[F6].piece\n\n    if f6_piece is not None and f6_piece.player != event.piece.player: # (1)\n        move_option = MoveOption(F6, extra=dict(summon_pawn=True), captures={F6}) # (2)\n        event.set_move_options(chain(event.move_options, [move_option])) # (3)\n</code></pre> <ol> <li>We only want to add the move option if the F6 square is occupied by an enemy piece.</li> <li>We create a move option that moves to the F6 square, and has an extra    attribute that we'll use later to know that we need to summon a pawn.</li> <li>Because move options are an iterable and not a list, we need to use the    <code>chain</code> function to add the move option to the existing move options.</li> </ol>"},{"location":"guide/tutorials/omnipotent-f6-pawn/#summoning-the-pawn","title":"Summoning the Pawn","text":"<pre><code>from chessmaker.chess.base.piece import AfterMoveEvent, BeforeCapturedEvent AfterCapturedEvent\n\n\ndef on_before_move(self, event: BeforeMoveEvent):\n    if event.move_option.extra.get(\"summon_pawn\"):\n        captured_piece = event.piece.board[F6].piece  # (1)\n        captured_piece.publish(BeforeCapturedEvent(captured_piece)) # (2)\n\n        pawn = self._pawn(event.piece.player)\n        event.piece.board[F6].piece = pawn  # (3)\n\n        captured_piece.publish(AfterCapturedEvent(captured_piece))\n        pawn.publish(AfterMoveEvent(pawn, event.move_option)) # (4)\n\n        event.set_cancelled(True)  # (5)\n</code></pre> <ol> <li>We save the captured piece so we can publish the <code>AfterCaptureEvent</code> later.</li> <li>We only publish a <code>BeforeCapturedEvent</code> and not a <code>BeforeMoveEvent</code> event because    the <code>BeforeMoveEvent</code> event has already been published (we're a subscriber to it).</li> <li>We create a new pawn and place it on the F6 square.</li> <li>We publish the move event for the pawn - and not for the piece that made the move.    This is because that piece isn't actually the one moving, as mentioned before.</li> <li>We cancel the actual move - because we don't want the piece to move    (And because we don't want 2 move events to be published).</li> </ol>"},{"location":"guide/tutorials/omnipotent-f6-pawn/#finishing-up","title":"Finishing Up","text":"<p>Again, all that's left is to add the rule to the board. Though this time it requires a bit more work:</p> <pre><code>def _pawn(player: Player):\n    if player == white:\n        return Pawn(white, Pawn.Direction.UP, promotions=[Bishop, Rook, Queen, Knight])\n    elif player == black:\n        return Pawn(black, Pawn.Direction.DOWN, promotions=[Bishop, Rook, Queen, Knight])\n\nboard = Board(\n    ...\n    rules=[OmnipotentF6Pawn(pawn=_pawn)]\n)\n</code></pre> <p>And that's it! This was probably the most complicated rule we've made so far, and it shows how we can do almost anything with ChessMaker.</p> <p></p>"},{"location":"guide/tutorials/siberian-swipe/","title":"Siberian Swipe","text":""},{"location":"guide/tutorials/siberian-swipe/#introduction","title":"Introduction","text":"<p>Siberian Swipe is a rule that originated from r/AnarchyChess. With rules like this, there's no official place we can find out how it works, so we have to define it ourselves.</p>"},{"location":"guide/tutorials/siberian-swipe/#defining-the-rule","title":"Defining the Rule","text":"<p>When a rook hasn't moved yet, it can skip any pieces on it's file in order to capture a distant enemy rook.</p>"},{"location":"guide/tutorials/siberian-swipe/#structuring-the-rule","title":"Structuring the Rule","text":"<p>Now that we know what the rule does, we can start building our rule. Because our rule only applies to Rooks - we only need to subscribe to rook events. And because we only need to add to where the rook can move to, and not how the movement works (We're just capturing a piece - not doing anything special like summoning a piece or moving a piece to a different location) - we only need to subscribe to the <code>BeforeGetMoveOptions</code> event.</p> <p>In addition, if rooks are added in the middle of the game (For example by a promotion), the rule also needs to apply to them. So we need to do 3 things:</p> <ul> <li> <p>For all</p> <ul> <li>Current rooks</li> <li>Rooks that will be added in the future</li> </ul> </li> <li> <p>We need to</p> <ul> <li>Add a capture move option.</li> </ul> </li> </ul> siberian_swipe.py<pre><code>from chessmaker.chess.base.rule import Rule\nfrom chessmaker.chess.base.board import AfterNewPieceEvent, Board\nfrom chessmaker.chess.base.piece import Piece, BeforeGetMoveOptionsEvent\nfrom chessmaker.chess.pieces.rook import Rook\nfrom chessmaker.events import EventPriority\n\nclass SiberianSwipe(Rule):\n    def on_join_board(self, board: Board):\n        for piece in board.get_pieces():\n            self.subscribe_to_piece(piece)\n        board.subscribe(AfterNewPieceEvent, self.on_new_piece)\n\n    def subscribe_to_piece(self, piece: Piece):\n        if isinstance(piece, Rook):\n            piece.subscribe(BeforeGetMoveOptionsEvent, self.on_before_get_move_options, EventPriority.HIGH) # (1)\n\n    def on_new_piece(self, event: AfterNewPieceEvent):\n        self.subscribe_to_piece(event.piece)\n\n    def on_before_get_move_options(self, event: BeforeGetMoveOptionsEvent):\n        pass # (2)\n\n    def clone(self):\n        return SiberianSwipe() # (3)\n</code></pre> <ol> <li>When adding move options, it's generally a good idea to add them with a high priority. So that rules which remove options will be able to run after this rule and remove it if needed.</li> <li>We'll implement this later. </li> <li>Because our rule is stateless, we don't have to do anything special when cloning it.</li> </ol>"},{"location":"guide/tutorials/siberian-swipe/#implementing-the-rule","title":"Implementing the Rule","text":"<p>Now all that's left to do is implement <code>on_before_get_move_options</code>. Use the annotations to help you understand what's going on.</p> siberian_swipe.py<pre><code>from itertools import chain\n\nfrom chessmaker.chess.base.move_option import MoveOption\nfrom chessmaker.chess.base.piece import BeforeGetMoveOptionsEvent\nfrom chessmaker.chess.piece_utils import is_in_board\nfrom chessmaker.chess.pieces.rook import Rook\n\n  def on_before_get_move_options(self, event: BeforeGetMoveOptionsEvent):\n      move_options = event.move_options\n      rook: Rook = event.piece\n      board = event.piece.board # (1)\n      player = event.piece.player\n      position = event.piece.position\n      new_move_options = []\n\n      if rook.moved: # (2)\n          return\n\n      for direction in [(0, 1), (0, -1)]: # (3)\n          enemy_position = position.offset(*direction)\n\n          while is_in_board(board, enemy_position): # (4)\n              enemy_piece = board[enemy_position].piece\n\n              if isinstance(enemy_piece, Rook) and enemy_piece.player != player: # (5)\n                  move_option = MoveOption(\n                      enemy_position,\n                      captures={enemy_position},\n                      extra=dict(siberian_swipe=True) # (6)\n                  )\n                  new_move_options.append(move_option)\n\n              enemy_position = enemy_position.offset(*direction)\n\n      event.set_move_options(chain(move_options, new_move_options)) # (7)\n</code></pre> <ol> <li>As mentioned earlier, it is recommended to use the event's board and not the one passed to us in <code>on_join_board</code>.</li> <li>If the rook has moved, it can't do a siberian swipe.</li> <li>We check both up and down.</li> <li>We search for rooks in that direction - ignoring all pieces that might block us, and use <code>piece_utils.is_in_board</code> to check if we reached the edge of the board (or a hole).</li> <li>We want our move to be able to skip over all pieces, so we ignore all pieces that aren't enemy rooks.</li> <li>If there is, we create a move option that captures it. Notice that  we add <code>extra=dict(siberian_swipe=True)</code> to the move option. For our use case, this is only used for display purposes, but if we wanted to modify how the move works using the <code>BeforeMoveEvent</code> and <code>AfterMoveEvent</code> events, we could use this to check if the move is a siberian swipe.</li> <li>Because the move options are an iterable, we can't just append to them. Instead, we use itertools.chain to create a new iterable that contains both the old move options, and the new move option we created.</li> </ol>"},{"location":"guide/tutorials/siberian-swipe/#finishing-up","title":"Finishing Up","text":"<p>Now that we've implemented our rule, we can add it to the board:</p> <pre><code>board = Board(\n    ...\n    rules=[SiberianSwipe()]\n)\n</code></pre> <p>And that's it! We've implemented a rule that adds a new move option to rooks. Let' see it in action:</p> <p></p>"}]}